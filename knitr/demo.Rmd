---
title: "Brainconductor demo"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setting up

We first install the relevant packages, \texttt{brcbase} (which contains
the core code needed for this demo) and \texttt{brcdata} (which contains the
example datasets).

```{r, cache = T}
library(devtools)
devtools::install_github("cdgreenidge/brcbase", ref = "kevin", subdir = "brcbase")
devtools::install_github("linnylin92/brcdata", ref = "kevin")
```

## Basics of \texttt{brcbase}

### The \texttt{BrcFmri} class, through a functional MRI

Let us investigate first \texttt{COBRE\_0040071\_funcSeg}, the functional MRI scan
of subject 0040071 in the COBRE repository. We can look up more information on this
dataset using \texttt{?COBRE\_0040071\_funcSeg}.

```{r}
library(brcbase)
library(brcdata)
dat <- brcdata::COBRE_0040071_funcSeg
class(dat)
summary(dat)
```

We see that from the summary that \texttt{dat} represents an fMRI that has
dimension $61 \times 73 \times 61$, has $82470$ parcels in its parcellation, and
has a scan length of $5$, meaning there are $5$ time indices. Let's dig into how this
data is stored. We have coded an \texttt{print} function for the \texttt{BrcFmri}
class to give you an overview of the contents of \texttt{dat}.

```{r}
dat
```


We see some distinctive components of \texttt{dat}, an object of the \texttt{BrcFmri}
class. These are \texttt{data2d}, \texttt{id}, and \texttt{parcellation}. 
```{r}
names(dat)
```

Let's first start with the last component, \texttt{parcellation}. It is an object
of class \texttt{BrcParcellation}.
```{r}
dat$parcellation
class(dat$parcellation)
length(dat$parcellation$partition)
```
We see that it has two elements, \texttt{dim3d} and \texttt{partition}. 
Here, \texttt{dim3d} represents the size of the fMRI scan, which is
$61 \times 73 \times 61$ voxels in our case. Next, \texttt{partition} is a vector of 
length $271633$ (which is equal to $61*73*61$), one element for each voxel.
Each element in this vector corresponds to a specific voxel (which is not made
explicit to the user), and the values of each element corresponds to which
parcel the corresponding voxel belongs in. Elements with $0$ are have 
a special meaning to denote
that its corresponding voxel are empty (i.e., there is no time-series information
for these voxels). For example, these empty voxels could represent voxels outside the
skull.

In our case, we see that there are
82470 unique parcellations (excluding the voxels with the $0$ value). We also
see that each parcel has only one voxel each. This means that this is the
singleton parcellation. In the later sections, we will discuss how to incorporate
parcellations where each parcel contains many voxels.
```{r}
length(unique(dat$parcellation$partition))
table(table(dat$parcellation$partition))
```

The next component we will discuss is \texttt{data2d}. 
In our case, this is a $5 \times 82470$ matrix,
where each column represents a different time index and each row represents a different 
voxel. (Recall that there were 82470 parcels based on \texttt{parcellation}.)
We call this the ``2d'' representation since it ignores spatial
information, as it is unclear a priori which voxels neighbor which voxels.

The last component is \texttt{id}, which allows the researcher (you) to
add some unique identifier to this fMRI data. This will have utility later on
when we link fMRI data to phenotype data.

### Manipulating the data representation

Our data \texttt{dat} was in the 2d representation. We discuss how to make it
transform it into the ``4d'' representation, which will explicitly encode 
which voxels are spatially adjacent to which voxels.
```{r}
dat4d <- data2dTo4d(dat$data2d, dat$parcellation)
dim(dat4d)
class(dat4d)
```

We see that \texttt{dat4d} is an \texttt{array} object with dimensions
$61 \times 73 \times 61 \times 5$, exactly what we would've expected had we worked
with a \texttt{nifti} object (using previously established NifTI standards).
Here, the first three dimensions represent the $(x,y,z)$ spatial coordinates,
so we can easily discern which voxels are spatially adjacent to which voxels.
The last dimension encode the time series. 

We can do a simple checks to ensure our understanding. First, we can
count how many non-zero voxels there are in any of the 5 time intervals.
```{r}
apply(dat4d, 4, function(x){length(which(x != 0))})
```
In each of the 5 time intervals, there are 82470 non-zero voxels, which is
what we expected.

### Applying a parcellation

Suppose we wanted to apply a (non-trivial) parcellation to \texttt{dat}.
That is, we wanted to reduce the dimensionality of data from 82470 dimensions
(one dimension for each voxel, since each voxel represents a different time series)
to a substantially smaller dimensionality. To do this, we will need a
parcellation encoded by the \texttt{BrcParcellation} class. We have
an example of one in the \texttt{brcData} package.

```{r}
aal <- brcdata::AAL_3mm
summary(aal)
class(aal)
aal
```

This is the AAL (Automated Anatomical Labeling) parcellation for 3 millimeter voxels.
More information on this parcellation can be found with the \texttt{?AAL\_3mm} command.
Notice that \texttt{aal} has the same dimension (based on \texttt{aal\$dim3d}) as
\texttt{dat}. This is important, as we will not be able to apply the \texttt{aal}
parcellation onto \texttt{dat} if their 3d dimensions differed. Unsurprisingly, we
see that the representation of \texttt{aal} is similar to that of \texttt{dat\$parcellation}
as both are objects of the \texttt{BrcParcellation} class.

However, we now will show that unlike \texttt{dat\$parcellation}, \texttt{aal} does
not include singleton parcels. To do this, we plot how many voxels are in each parcel,
sorted from fewest to most. We exclude the ``$0$'' parcel (again, which represents empty space).
```{r}
vec <- aal$partition[aal$partition != 0]
length(unique(vec))
quantile(table(vec))
plot(as.numeric(sort(table(vec))), xlab = "Parcel index", ylab = "Parcel size", 
     pch = 16, cex = 2)
```

We see that more than half the parcels contain more than 400 voxels, and there are
90 parcels total (again, excluding the ``$0$'' parcel).

Now we want to apply \texttt{aal} to \texttt{dat}, returning a new dataset
where there are only 90 dimensions (i.e., 90 time series) instead of 82470 dimensions.

```{r}
dat_aal <- reduce(dat, aal, func = reduce_mean)
summary(dat_aal)
dim(dat_aal$data2d)
```

We see that there are only 90 parcels in our new dataset, \texttt{dat\_aal},
and the 2d representation of \texttt{dat\_aal} is now a $5 \times 90$ matrix.
We used a function called \texttt{reduce\_mean} to summarize the time series
of all the voxels in the same parcellation (according to \texttt{aal}) into
one time series using the mean. There are other functions we could have used
such as \texttt{reduce\_pca}. We encourage the reader to read about these 
functions using the commands \texttt{?reduce}, \texttt{?reduce\_mean}, and \texttt{?reduce\_pca}.

If we count how many voxels are included in our new dataset \texttt{dat\_aal}, 
we will notice something.
```{r}
length(which(dat_aal$parcellation$partition != 0))
length(which(dat$parcellation$partition != 0))
```

This means only 47636 voxels are accounted for in \texttt{dat\_aal}, down from
the original number of 82470 voxels in \texttt{dat}. (Remember, the number of 
parcels in \texttt{dat} is equal to the number of voxels since \texttt{dat\$parcellation}
is the singleton parcellation.) This is because not all the
voxels represented in the \texttt{dat\_aal}  parcellation are represented in the 
\texttt{dat\$parcellation} parcellation, and vice-versa. In neuroscience analyses,
this can thought of as a region-ofinterest (RoI) analysis, as not every voxel is 
scientifically interesting to study. If the researcher wanted to ``fill'' the 
\texttt{aal} parcellation so as many of the original 82470 original voxels are
accounted for in the new, reduced dataset, we discuss functions to achieve this
in later sections.

### Building a \texttt{BrcFmri} object

## Visualization

## Statistics

## Example custom packages: Parcellation

## Summary
