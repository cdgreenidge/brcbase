---
title: "Brainconductor demo"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setting up

We first install the relevant packages, \texttt{brcbase} (which contains
the core code needed for this demo) and \texttt{brcdata} (which contains the
example datasets).

```{r, cache = T}
library(devtools)
devtools::install_github("cdgreenidge/brcbase", ref = "kevin", subdir = "brcbase")
devtools::install_github("linnylin92/brcdata", ref = "kevin")
```

## Basics of \texttt{brcbase}

### The \texttt{BrcFmri} class, through a functional MRI

Let us investigate first \texttt{COBRE\_0040071\_funcSeg}, the functional MRI scan
of subject 0040071 in the COBRE repository. We can look up more information on this
dataset using \texttt{?COBRE\_0040071\_funcSeg}.

```{r}
library(brcbase)
library(brcdata)
dat <- brcdata::COBRE_0040071_funcSeg
class(dat)
summary(dat)
```

We see that from the summary that \texttt{dat} represents an fMRI that has
dimension $61 \times 73 \times 61$, has $82470$ parcels in its parcellation, and
has a scan length of $5$, meaning there are $5$ time indices. Let's dig into how this
data is stored. We have coded an \texttt{print} function for the \texttt{BrcFmri}
class to give you an overview of the contents of \texttt{dat}.

```{r}
dat
```


We see some distinctive components of \texttt{dat}, an object of the \texttt{BrcFmri}
class. These are \texttt{data2d}, \texttt{id}, and \texttt{parcellation}. 
```{r}
names(dat)
```

Let's first start with the last component, \texttt{parcellation}. It is an object
of class \texttt{BrcParcellation}.
```{r}
dat$parcellation
class(dat$parcellation)
length(dat$parcellation$partition)
```
We see that it has two elements, \texttt{dim3d} and \texttt{partition}. 
Here, \texttt{dim3d} represents the size of the fMRI scan, which is
$61 \times 73 \times 61$ voxels in our case. Next, \texttt{partition} is a vector of 
length $271633$ (which is equal to $61*73*61$), one element for each voxel.
Each element in this vector corresponds to a specific voxel (which is not made
explicit to the user), and the values of each element corresponds to which
parcel the corresponding voxel belongs in. Elements with $0$ are have 
a special meaning to denote
that its corresponding voxel are empty (i.e., there is no time-series information
for these voxels). For example, these empty voxels could represent voxels outside the
skull.

In our case, we see that there are
82470 unique parcellations (excluding the voxels with the $0$ value). We also
see that each parcel has only one voxel each. This means that this is the
singleton parcellation. In the later sections, we will discuss how to incorporate
parcellations where each parcel contains many voxels.
```{r}
length(unique(dat$parcellation$partition))
table(table(dat$parcellation$partition))
```

The next component we will discuss is \texttt{data2d}. 
In our case, this is a $5 \times 82470$ matrix,
where each column represents a different time index and each row represents a different 
voxel. (Recall that there were 82470 parcels based on \texttt{parcellation}.)
We call this the ``2d'' representation since it ignores spatial
information, as it is unclear a priori which voxels neighbor which voxels.

The last component is \texttt{id}, which allows the researcher (you) to
add some unique identifier to this fMRI data. This will have utility later on
when we link fMRI data to phenotype data.

### Manipulating the data representation

Our data \texttt{dat} was in the 2d representation. We discuss how to make it
transform it into the ``4d'' representation, which will explicitly encode 
which voxels are spatially adjacent to which voxels.
```{r}
dat4d <- data2dTo4d(dat$data2d, dat$parcellation)
dim(dat4d)
class(dat4d)
```

We see that \texttt{dat4d} is an \texttt{array} object with dimensions
$61 \times 73 \times 61 \times 5$, exactly what we would've expected had we worked
with a \texttt{nifti} object (using previously established NifTI standards).
Here, the first three dimensions represent the $(x,y,z)$ spatial coordinates,
so we can easily discern which voxels are spatially adjacent to which voxels.
The last dimension encode the time series. 

We can do a simple checks to ensure our understanding. First, we can
count how many non-zero voxels there are in any of the 5 time intervals.
```{r}
apply(dat4d, 4, function(x){length(which(x != 0))})
```
In each of the 5 time intervals, there are 82470 non-zero voxels, which is
what we expected.

### Applying a parcellation

Suppose we wanted to apply a (non-trivial) parcellation to \texttt{dat}.
That is, we wanted to reduce the dimensionality of data from 82470 dimensions
(one dimension for each voxel, since each voxel represents a different time series)
to a substantially smaller dimensionality. To do this, we will need a
parcellation encoded by the \texttt{BrcParcellation} class. We have
an example of one in the \texttt{brcData} package.

```{r}
aal <- brcdata::AAL_3mm
summary(aal)
class(aal)
aal
```

This is the AAL (Automated Anatomical Labeling) parcellation for 3 millimeter voxels.
More information on this parcellation can be found with the \texttt{?AAL\_3mm} command.
Notice that \texttt{aal} has the same dimension (based on \texttt{aal\$dim3d}) as
\texttt{dat}. This is important, as we will not be able to apply the \texttt{aal}
parcellation onto \texttt{dat} if their 3d dimensions differed. Unsurprisingly, we
see that the representation of \texttt{aal} is similar to that of \texttt{dat\$parcellation}
as both are objects of the \texttt{BrcParcellation} class.

However, we now will show that unlike \texttt{dat\$parcellation}, \texttt{aal} does
not include singleton parcels. To do this, we plot how many voxels are in each parcel,
sorted from fewest to most. We exclude the ``$0$'' parcel (again, which represents empty space).
```{r}
vec <- aal$partition[aal$partition != 0]
length(unique(vec))
quantile(table(vec))
plot(as.numeric(sort(table(vec))), xlab = "Parcel index", ylab = "Parcel size", 
     pch = 16, cex = 2)
```

We see that more than half the parcels contain more than 400 voxels, and there are
90 parcels total (again, excluding the ``$0$'' parcel).

Now we want to apply \texttt{aal} to \texttt{dat}, returning a new dataset
where there are only 90 dimensions (i.e., 90 time series) instead of 82470 dimensions.

```{r}
dat_aal <- reduce(dat, aal, func = reduce_mean)
summary(dat_aal)
dim(dat_aal$data2d)
```

We see that there are only 90 parcels in our new dataset, \texttt{dat\_aal},
and the 2d representation of \texttt{dat\_aal} is now a $5 \times 90$ matrix.
We used a function called \texttt{reduce\_mean} to summarize the time series
of all the voxels in the same parcellation (according to \texttt{aal}) into
one time series using the mean. There are other functions we could have used
such as \texttt{reduce\_pca}. We encourage the reader to read about these 
functions using the commands \texttt{?reduce}, \texttt{?reduce\_mean}, and \texttt{?reduce\_pca}.

If we count how many voxels are included in our new dataset \texttt{dat\_aal}, 
we will notice something.
```{r}
length(which(dat_aal$parcellation$partition != 0))
length(which(dat$parcellation$partition != 0))
```

This means only 47636 voxels are accounted for in \texttt{dat\_aal}, down from
the original number of 82470 voxels in \texttt{dat}. (Remember, the number of 
parcels in \texttt{dat} is equal to the number of voxels since \texttt{dat\$parcellation}
is the singleton parcellation.) This is because not all the
voxels represented in the \texttt{dat\_aal}  parcellation are represented in the 
\texttt{dat\$parcellation} parcellation, and vice-versa. In neuroscience analyses,
this can thought of as a region-ofinterest (RoI) analysis, as not every voxel is 
scientifically interesting to study. If the researcher wanted to ``fill'' the 
\texttt{aal} parcellation so as many of the original 82470 original voxels are
accounted for in the new, reduced dataset, we discuss functions to achieve this
in later sections.

### Building a \texttt{BrcFmri} and \texttt{BrcParcellation} object

Now that we have discussed manipulate an existing \texttt{BrcFmri} object,
we need to discuss how to create your own \texttt{BrcFmri} object. We discuss two ways to do this.

The first way is to use a function designed for easy convenience, \texttt{buildBrcFmri}. 
This function takes in a 4D array (using the ``4d'' representation of an fMRI scan mentioned in previous
subsections) and outputs a \texttt{brcFmri} object (which, as discussed earlier, contains a
\texttt{brcParcellation} object). When using this function, the parcellation in \texttt{brcParcellation}
will always be the singleton parcellation. If you wanted to use a different parcellation, 
you can use the \texttt{reduce} function mentioned in the previous subsection. 

```{r}
#we first make an example fMRI dataset
set.seed(10)
fmri <- array(0, dim = c(5,5,5,4))
fmri[2:4,2:4,1:5,] <- rnorm(3*3*5*4)
fmri[1,3,1:5,] <- rnorm(5*4)

dat <- buildBrcFmri(fmri)
class(dat)
dat
```

As a side note, there is also a \texttt{buildBrcParcellation} function, which takes in a 3D array
and outputs a \texttt{brcParcellation} object. Unlike \texttt{buildBrcFmri}, this function does not
always output the singleton parcellation. You can pass in a 3D array where unique non-zero elements denote
which voxels belong to which parcels. (Again, remember that a voxel with value ``0'' will denote
that that voxel does not belong to any parcel.)

```{r}
#we first make an example parcellation dataset
arr <- array(0, c(5,5,5))
arr[2:4,2:4,1:3] <- 1
arr[2:4,2:4,4:5] <- 2
arr[1,3,1:5] <- 3

parcellation <- buildBrcParcellation(arr)
class(parcellation)
parcellation
```

The second way is to directly pass in the appropriate inputs into the \texttt{BrcParcellation} and \texttt{BrcFmri} functions
to output \texttt{brcParcellation} and \texttt{brcFmri} objects respectively.
This method requires the user to have a bit more knowledge as these functions will explicitly error if the given
inputs are invalid, however this method gives the user more control over how the data is represented. We strongly
advise the user to read the documentation of \texttt{BrcParcellation} and \texttt{BrcFmri} if he/she chooses to 
use this method. 

Briefly summarizing, \texttt{BrcParcellation} requires a length-3 vector \texttt{dim3d} (to denote the 3-dimensional
dimensions of the parcellation) and a vector of non-negative integers \texttt{partition}. The length of \texttt{partition}
must be equal to the product of all 3 numbers in \texttt{dim3d}, and its elements must be $\{0, 1, 2, \ldots, k\}$ if
there are $k$ parcels.

```{r}
#we'll work with the same arr object above, and demonstrate how to convert it 
# into the proper form for BrcParcellation
dim3d <- dim(arr)
partition <- as.numeric(arr)
parcellation2 <- BrcParcellation(dim3d = dim3d, partition = partition)
parcellation2

#demonstrate that these two parcellations are equal
all(parcellation$dim3d == parcellation2$dim3d)
all(parcellation$partition == parcellation2$partition)
```

Meanwhile, \texttt{BrcFmri} requires a (2D) matrix \texttt{data2d} to represent the fMRI data in the ``2d'' representation,
an optional string \texttt{id} to identify the subject the data belongs to, and \texttt{parcellation} which is a \texttt{brcParcellation} object.
If there are $k$ parcels in the \texttt{parcellation}, then \texttt{data2d} must have $k$ columns. The number of rows in \texttt{data2d}
correspond to how many time slices were recorded in the fMRI data.

```{r}
#we'll work with the same fmri object above, and demonstrate how to convert it 
# into the proper form for BrcFmri
data2d <- data4dTo2d(fmri)
idx <- which(colSums(data2d) == 0)
data2d <- data2d[,-idx] 
partition_fmri <- as.numeric(fmri[,,,1])
len <- sum(partition_fmri != 0); partition_fmri[partition_fmri != 0] <- 1:50
parcellation_fmri <- BrcParcellation(dim3d = dim(fmri)[1:3], partition = partition_fmri)

dat2 <- BrcFmri(data2d = data2d, id = "", parcellation = parcellation_fmri)
dat2

#demonstrate that these two parcellations are equal
all(dat$data2d == dat2$data2d)
all(dat$parcellation$dim3d == dat2$parcellation$dim3d)
all(dat$parcellation$partition == dat2$parcellation$partition)
```


Between the two ways, we suggest users to use the first way since other packages such as \texttt{oro.nifti}
(which allow users to read \texttt{niFti} files in \texttt{R}) represent the data as a 4D array.
\textcolor{red}{Is there an example we can add of downloading data from the web, using oro.nifti to open, and then converting to
brcFmri object?}

## Visualization

## Statistics

## Example custom packages: Parcellation

The Brainconductor suite organizes objects such that it is easy to extend the
functionality of existing objects. We demonstrate this using the \texttt{brcparcellation}
parcellation, which provides many functions that manipulate parcellations and
calculate various properties. 

```{r, cache = T}
library(devtools)
devtools::install_github("linnylin92/brcparcellation", ref = "kevin")
library(brcparcellation)
```

Let's look at the AAL parcellation that we used earlier. Using the \texttt{brcparcellation} package, we can compute the surface area of a specific parcel.

```{r}
aal <- brcdata::AAL_3mm
brcparcellation::surfaceArea(aal, parcel = 1)
```


## Summary
